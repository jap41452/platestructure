<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Plate Module — UI + Conforming Tri Mesh (3D)</title>

<style>
  :root{
    --W: 900px;
    --panel-bg: #f5f7fb;
    --card: #ffffff;
    --ink: #0b1220;
    --muted: #5b6678;
    --border: #d7dde6;
    --blue: #2563eb;
    --green: #16a34a;
    --amber: #f59e0b;
    --red: #dc2626;

    --free:  #6b7280;
    --ss:    #2563eb;
    --fixed: #dc2626;
  }

  body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--ink); background:#fff; }

  .xl4-wrap{
    width: var(--W);
    margin: 16px auto;
    border: 1px solid var(--border);
    background: var(--panel-bg);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
  }

  .xl4-head{
    padding: 14px 16px;
    background: linear-gradient(90deg, #0b1220, #111c33);
    color:#fff;
    display:flex;
    align-items:center;
    justify-content: space-between;
  }
  .xl4-title{ font-weight:900; letter-spacing:-0.02em; }
  .xl4-sub{ font-size:12px; opacity:0.85; margin-top:2px; }

  .xl4-body{
    display:grid;
    grid-template-columns: 330px 1fr;
    gap: 12px;
    padding: 12px;
  }

  .card{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
  }

  .section-title{ font-weight:850; letter-spacing:-0.01em; margin:0 0 8px 0; font-size:14px; }
  .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }

  label{ display:block; font-size:12px; color: var(--muted); margin-bottom: 4px; }

  input, select{
    width:100%;
    padding: 8px 9px;
    border: 1px solid var(--border);
    border-radius: 10px;
    font-size: 13px;
    outline:none;
    background:#fff;
  }
  input:focus, select:focus{
    border-color: #9db7ff;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
  }

  .row{ display:flex; gap:8px; align-items:center; }

  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    border: 1px solid var(--border);
    background:#fff;
    color: var(--ink);
    padding: 9px 10px;
    border-radius: 12px;
    font-weight: 750;
    cursor:pointer;
    user-select:none;
    font-size: 13px;
  }
  .btn:hover{ border-color:#b8c3d6; }
  .btn.primary{ background: var(--blue); color:#fff; border-color: var(--blue); }
  .btn.primary:hover{ filter: brightness(0.98); }
  .btn.danger{ background: var(--red); color:#fff; border-color: var(--red); }
  .btn.small{ padding:6px 8px; border-radius: 10px; font-size:12px; font-weight:750; }

  .list{ margin:0; padding:0; list-style:none; display:flex; flex-direction:column; gap:8px; }
  .item{ border: 1px solid var(--border); border-radius: 12px; padding: 10px; background:#fff; }
  .item-top{ display:flex; align-items:flex-start; justify-content: space-between; gap: 10px; }
  .pill{
    font-size: 11px; font-weight: 800;
    border-radius: 999px; padding: 4px 8px;
    border: 1px solid var(--border);
    color: var(--muted);
    background: #f8fafc;
  }
  .muted{ color: var(--muted); font-size:12px; }

  .canvasWrap{
    background:#ffffff;
    border-radius: 12px;
    border: 1px solid var(--border);
    overflow:hidden;
    position: relative;
    min-height: 560px;
  }

  #gl{ width:100%; height:560px; display:block; }

  .hud{
    position:absolute;
    left: 10px;
    top: 10px;
    background: rgba(248,250,252,0.95);
    border: 1px solid rgba(215,221,230,0.95);
    border-radius: 12px;
    padding: 10px;
    width: 300px;
  }
  .hud .k{ font-size:12px; color: var(--muted); margin-bottom:4px; }
  .hud .v{ font-size:12px; font-weight:800; }

  .legend{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
  .leg{ display:flex; align-items:center; gap:6px; font-size:11px; color: var(--muted); font-weight:700; }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
  .dot.free{ background: var(--free); }
  .dot.ss{ background: var(--ss); }
  .dot.fixed{ background: var(--fixed); }

  .modalBackdrop{
    position: fixed;
    inset: 0;
    background: rgba(11, 18, 32, 0.55);
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 50;
    padding: 20px;
  }
  .modal{
    width: min(560px, 100%);
    background:#fff;
    border-radius: 14px;
    border: 1px solid var(--border);
    box-shadow: 0 22px 60px rgba(0,0,0,0.25);
    overflow:hidden;
  }
  .modalHead{
    padding: 12px 14px;
    background:#f8fafc;
    border-bottom: 1px solid var(--border);
    display:flex;
    justify-content: space-between;
    align-items:center;
    gap: 10px;
  }
  .modalTitle{ font-weight: 900; letter-spacing:-0.02em; }
  .modalBody{ padding: 14px; }
  .modalFoot{
    padding: 12px 14px;
    border-top: 1px solid var(--border);
    display:flex;
    justify-content:flex-end;
    gap: 8px;
    background:#fff;
  }

  .err{
    margin-top:8px;
    padding:8px 10px;
    border:1px solid #fecaca;
    background:#fff1f2;
    color:#7f1d1d;
    border-radius:10px;
    font-size:12px;
    display:none;
  }
</style>




<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<!-- poly2tri (UMD) -->
</head>

<body>
<div class="xl4-wrap">
  <div class="xl4-head">
    <div>
      <div class="xl4-title">Plate Module — Conforming Tri Mesh (3D)</div>
      <div class="xl4-sub">CDT mesh with holes + conforming patch boundaries; ready for 6-noded upgrade next.</div>
    </div>
    <div class="row">
      <button class="btn small" id="btnExport">Export JSON</button>
      <button class="btn small danger" id="btnReset">Reset</button>
    </div>
  </div>

  <div class="xl4-body">
    <!-- LEFT PANEL -->
    <div class="card">
      <div class="section-title">Overall geometry</div>

      <div class="grid2">
        <div>
          <label>Overall shape</label>
          <select id="shapeType">
            <option value="rect">Rectangular</option>
            <option value="circle">Circular</option>
          </select>
        </div>
        <div>
          <label>Units (label only for now)</label>
          <select id="units">
            <option value="in-lbf">in / lbf</option>
            <option value="m-n">m / N</option>
          </select>
        </div>
      </div>

      <div id="rectDims" style="margin-top:10px;">
        <div class="grid2">
          <div><label>Width (W)</label><input id="W" type="number" step="any" value="20"/></div>
          <div><label>Length (L)</label><input id="L" type="number" step="any" value="30"/></div>
        </div>
      </div>

      <div id="circDims" style="margin-top:10px; display:none;">
        <div><label>Diameter (D)</label><input id="D" type="number" step="any" value="24"/></div>
      </div>

      <div style="margin-top:10px;" class="grid2">
        <div><label>Thickness (t)</label><input id="t" type="number" step="any" value="0.25"/></div>
        <div><label>Modulus (E)</label><input id="E" type="number" step="any" value="30000000"/></div>
      </div>

      <div style="margin-top:10px;">
        <label>Material weight density (ρ)</label>
        <input id="rho" type="number" step="any" value="0.283"/>
      </div>

      <div style="margin-top:10px;">
        <label>Target element size (h)</label>
        <input id="h" type="number" step="any" value="1.0"/>
        <div class="muted" style="margin-top:6px;">No tangents/overlaps enforced using ε = 0.05 h.</div>
      </div>

      <div class="row" style="margin-top:10px; flex-wrap:wrap;">
        <button class="btn primary" id="btnBuild">Build / Update + Mesh</button>
      </div>

      <div class="err" id="errBox"></div>

      <hr style="border:none;border-top:1px solid var(--border); margin:12px 0;" />

      <div class="section-title">Features</div>
      <div class="row" style="flex-wrap:wrap; gap:8px;">
        <button class="btn" id="btnAddCircCut">+ Circular cutout</button>
        <button class="btn" id="btnAddRectCut">+ Rectangular cutout</button>
        <button class="btn" id="btnAddCircPatch">+ Circular section (patch)</button>
        <button class="btn" id="btnAddRectPatch">+ Rectangular section (patch)</button>
      </div>

      <div style="margin-top:12px;">
        <div class="section-title">Feature list</div>
        <ul class="list" id="featureList"></ul>
        <div class="muted" id="featureEmpty">No features yet.</div>
      </div>

      <hr style="border:none;border-top:1px solid var(--border); margin:12px 0;" />

      <div class="section-title">Boundary conditions</div>
      <div class="muted">Click a boundary edge in the 3D view. Then set BC below:</div>

      <div style="margin-top:10px;" class="grid2">
        <div>
          <label>Selected boundary</label>
          <input id="selBoundary" type="text" value="(none)" readonly />
        </div>
        <div>
          <label>BC type</label>
          <select id="bcType" disabled>
            <option value="free">Free</option>
            <option value="ss">Simply supported</option>
            <option value="fixed">Fixed</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnApplyBC" disabled>Apply BC</button>
      </div>

      <div class="muted" style="margin-top:8px;">
        Outer circle perimeter is one BC group. Rect outer has 4 groups. Each cutout is one BC group.
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="canvasWrap">
      <canvas id="gl"></canvas>

      <div class="hud">
        <div class="k">Mouse</div>
        <div class="v">Left-drag rotate • Wheel zoom • Right-drag pan</div>

        <div class="legend">
          <div class="leg"><span class="dot free"></span> Free</div>
          <div class="leg"><span class="dot ss"></span> Simply supported</div>
          <div class="leg"><span class="dot fixed"></span> Fixed</div>
        </div>

        <div style="margin-top:10px;">
          <div class="k">Picked object</div>
          <div class="v" id="pickedLabel">(none)</div>
        </div>

        <div style="margin-top:10px;">
          <div class="k">Mesh</div>
          <div class="v" id="meshStats">—</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modalBackdrop" id="modalBackdrop">
  <div class="modal">
    <div class="modalHead">
      <div class="modalTitle" id="modalTitle">Add feature</div>
      <button class="btn small" id="btnModalClose">Close</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalFoot">
      <button class="btn" id="btnModalCancel">Cancel</button>
      <button class="btn primary" id="btnModalSave">Save</button>
    </div>
  </div>
</div>

<script type="module">

import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import poly2tri from "https://esm.sh/poly2tri@2.3.0";


/***********************
 * Data model
 ***********************/
const model = {
  units: "in-lbf",
  shape: { type:"rect", W:20, L:30, D:24, t:0.25, E:30000000, rho:0.283, h:1.0 },
  features: [],
  bcs: {} // boundaryId -> free|ss|fixed
};

// Mesh storage (generated)
let mesh = null; // { V:[{x,y}], T:[{i1,i2,i3, region}], regions:{base:{t,p}, patchId:{t,p}}, boundaryEdgesById:{}, loops:{outer, cutouts, patches} }

/***********************
 * DOM
 ***********************/
const $ = (id)=>document.getElementById(id);

const shapeType = $("shapeType");
const units = $("units");
const rectDims = $("rectDims");
const circDims = $("circDims");
const featureList = $("featureList");
const featureEmpty = $("featureEmpty");
const errBox = $("errBox");

const selBoundary = $("selBoundary");
const bcType = $("bcType");
const btnApplyBC = $("btnApplyBC");
const pickedLabel = $("pickedLabel");
const meshStats = $("meshStats");

/***********************
 * Three.js
 ***********************/
const canvas = $("gl");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 5000);
camera.position.set(40, 35, 55);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0,0,0);

scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(40,70,20);
scene.add(dir);

const grid = new THREE.GridHelper(120, 24, 0xb8c3d6, 0xe5eaf2);
grid.position.y = -0.001;
scene.add(grid);
scene.add(new THREE.AxesHelper(20));

const grpSolid = new THREE.Group(); scene.add(grpSolid);     // extruded prisms by region
const grpWire  = new THREE.Group(); scene.add(grpWire);      // mesh wire lines
const grpBC    = new THREE.Group(); scene.add(grpBC);        // clickable BC tubes
const grpLoads = new THREE.Group(); scene.add(grpLoads);     // arrows

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selectedBoundaryId = null;

function bcColor(bc){
  if (bc === "fixed") return 0xdc2626;
  if (bc === "ss") return 0x2563eb;
  return 0x6b7280;
}

function resize(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  renderer.setSize(w,h,false);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", resize);

function clearGroup(g){
  while(g.children.length){
    const obj = g.children.pop();
    obj.traverse?.((c)=>{
      if (c.geometry) c.geometry.dispose?.();
      if (c.material){
        if (Array.isArray(c.material)) c.material.forEach(m=>m.dispose?.());
        else c.material.dispose?.();
      }
    });
  }
}

/***********************
 * Utilities
 ***********************/
function showErr(msg){
  errBox.style.display = msg ? "block" : "none";
  errBox.textContent = msg || "";
}
function fmt(n){
  if (typeof n !== "number" || !isFinite(n)) return "—";
  const a = Math.abs(n);
  if (a >= 1000) return n.toFixed(0);
  if (a >= 10) return n.toFixed(3).replace(/0+$/,'').replace(/\.$/,'');
  return n.toFixed(4).replace(/0+$/,'').replace(/\.$/,'');
}
function featureDimsText(f){
  if (f.shape === "circle") return `r = ${fmt(f.r)}`;
  return `w × l = ${fmt(f.w)} × ${fmt(f.l)}`;
}
function spanVal(){
  return (model.shape.type==="rect") ? Math.max(model.shape.W, model.shape.L) : model.shape.D;
}

/***********************
 * Feature list
 ***********************/
function renderFeatureList(){
  featureList.innerHTML = "";
  featureEmpty.style.display = model.features.length ? "none" : "block";

  model.features.forEach(f=>{
    const li = document.createElement("li");
    li.className = "item";

    const top = document.createElement("div");
    top.className = "item-top";

    const left = document.createElement("div");
    const kind = f.kind === "cutout" ? "Cutout" : "Section (patch)";
    const shape = f.shape === "circle" ? "Circle" : "Rect";
    left.innerHTML = `
      <div style="font-weight:900; letter-spacing:-0.01em;">${kind}: ${shape}</div>
      <div class="muted">Center (x,y) = (${fmt(f.cx)}, ${fmt(f.cy)})</div>
      <div class="muted">${featureDimsText(f)}</div>
      ${f.kind==="patch" ? `<div class="muted">tOverride=${fmt(f.tOverride)} • p=${fmt(f.pressure)}</div>` : ``}
    `;

    const right = document.createElement("div");
    right.style.display="flex";
    right.style.gap="6px";
    right.style.alignItems="center";
    right.innerHTML = `<span class="pill">${f.id}</span>`;

    const btnDel = document.createElement("button");
    btnDel.className = "btn small danger";
    btnDel.textContent = "Delete";
    btnDel.onclick = ()=>{
      model.features = model.features.filter(x=>x.id!==f.id);
      selectedBoundaryId = null;
      selBoundary.value = "(none)";
      bcType.disabled = true;
      btnApplyBC.disabled = true;
      buildAll();
    };

    right.appendChild(btnDel);
    top.appendChild(left);
    top.appendChild(right);
    li.appendChild(top);
    featureList.appendChild(li);
  });
}

/***********************
 * Modal
 ***********************/
const modalBackdrop = $("modalBackdrop");
const modalTitle = $("modalTitle");
const modalBody = $("modalBody");
const btnModalClose = $("btnModalClose");
const btnModalCancel = $("btnModalCancel");
const btnModalSave = $("btnModalSave");

let modalContext = null;

function openModal(ctx){
  modalContext = ctx;
  modalTitle.textContent = ctx.title;
  modalBody.innerHTML = ctx.html;
  modalBackdrop.style.display = "flex";
}
function closeModal(){
  modalBackdrop.style.display = "none";
  modalContext = null;
}
btnModalClose.onclick = closeModal;
btnModalCancel.onclick = closeModal;

function modalHtmlBase(extra){
  return `
    <div class="grid2">
      <div><label>Center X</label><input id="f_cx" type="number" step="any" value="0"/></div>
      <div><label>Center Y</label><input id="f_cy" type="number" step="any" value="0"/></div>
    </div>
    ${extra}
  `;
}

/***********************
 * Validation (no overlaps, no tangents, no outside)
 * Uses ε = 0.05 h
 ***********************/
function epsilon(){
  return 0.05 * model.shape.h;
}

function insideOuterWithClearance(f){
  const eps = epsilon();
  if (model.shape.type === "rect"){
    const W = model.shape.W, L = model.shape.L;
    if (f.shape === "circle"){
      return (Math.abs(f.cx) + f.r <= W/2 - eps) && (Math.abs(f.cy) + f.r <= L/2 - eps);
    } else {
      return (Math.abs(f.cx) + f.w/2 <= W/2 - eps) && (Math.abs(f.cy) + f.l/2 <= L/2 - eps);
    }
  } else {
    const R = model.shape.D/2;
    if (f.shape === "circle"){
      return (Math.hypot(f.cx, f.cy) + f.r <= R - eps);
    } else {
      const dx = f.w/2, dy = f.l/2;
      const corners = [
        [f.cx-dx, f.cy-dy], [f.cx+dx, f.cy-dy],
        [f.cx+dx, f.cy+dy], [f.cx-dx, f.cy+dy]
      ];
      return corners.every(([x,y]) => Math.hypot(x,y) <= R - eps);
    }
  }
}

function minSizeOK(f){
  const h = model.shape.h;
  if (f.shape === "circle"){
    return f.r >= 1.5*h;
  } else {
    return Math.min(f.w, f.l) >= 3*h;
  }
}

function overlapWithClearance(a,b){
  const eps = epsilon();

  if (a.shape === "circle" && b.shape === "circle"){
    const d = Math.hypot(a.cx-b.cx, a.cy-b.cy);
    return d < (a.r + b.r + eps);
  }

  if (a.shape === "rect" && b.shape === "rect"){
    const dx = Math.abs(a.cx-b.cx);
    const dy = Math.abs(a.cy-b.cy);
    const ox = (a.w+b.w)/2 + eps;
    const oy = (a.l+b.l)/2 + eps;
    // overlap (or too close) if overlapping in both axes with clearance
    return (dx < ox) && (dy < oy);
  }

  // circle-rect
  const c = (a.shape==="circle") ? a : b;
  const r = (a.shape==="rect") ? a : b;

  const dx = Math.max(Math.abs(c.cx - r.cx) - r.w/2, 0);
  const dy = Math.max(Math.abs(c.cy - r.cy) - r.l/2, 0);
  return (dx*dx + dy*dy) < (c.r + eps) * (c.r + eps);
}

btnModalSave.onclick = ()=>{
  if (!modalContext) return;
  showErr("");

  const read = (id)=>{
    const el = document.getElementById(id);
    if (!el) return null;
    const v = Number(el.value);
    return isFinite(v) ? v : null;
  };

  const cx = read("f_cx"), cy = read("f_cy");
  if (cx===null || cy===null){ showErr("Enter a valid center location (x,y)."); return; }

  const f = { id:`F${String(Date.now()).slice(-6)}`, kind: modalContext.kind, shape: modalContext.shape, cx, cy };

  if (modalContext.shape === "circle"){
    const r = read("f_r");
    if (r===null || r<=0){ showErr("Radius must be > 0."); return; }
    f.r = r;
  } else {
    const w = read("f_w"), l = read("f_l");
    if (w===null || l===null || w<=0 || l<=0){ showErr("Width/Length must be > 0."); return; }
    f.w = w; f.l = l;
  }

  if (modalContext.kind === "patch"){
    const tO = read("f_tO"), p = read("f_p");
    if (tO===null || tO<=0){ showErr("Override thickness must be > 0."); return; }
    if (p===null){ showErr("Pressure must be a valid number (use 0 if none)."); return; }
    f.tOverride = tO; f.pressure = p;
  }

  // size constraint tied to h
  if (!minSizeOK(f)){
    showErr(`Feature is too small relative to h. Use r ≥ 1.5h (circle) or min(w,l) ≥ 3h (rect).`);
    return;
  }

  // inside outer
  if (!insideOuterWithClearance(f)){
    showErr(`Feature must lie fully inside the plate with clearance ≥ ε (ε = 0.05h = ${fmt(epsilon())}).`);
    return;
  }

  // no overlap with existing features
  for (const g of model.features){
    if (overlapWithClearance(f,g)){
      showErr(`Feature overlaps/is too close to existing feature ${g.id}. Clearance ≥ ε required.`);
      return;
    }
  }

  model.features.push(f);
  closeModal();
  buildAll();
};

/***********************
 * Feature buttons
 ***********************/
$("btnAddCircCut").onclick = ()=>openModal({
  title: "Add circular cutout",
  kind:"cutout", shape:"circle",
  html: modalHtmlBase(`
    <div style="margin-top:10px;">
      <label>Radius (r)</label>
      <input id="f_r" type="number" step="any" value="2"/>
    </div>
  `)
});

$("btnAddRectCut").onclick = ()=>openModal({
  title: "Add rectangular cutout",
  kind:"cutout", shape:"rect",
  html: modalHtmlBase(`
    <div class="grid2" style="margin-top:10px;">
      <div><label>Width (w)</label><input id="f_w" type="number" step="any" value="4"/></div>
      <div><label>Length (l)</label><input id="f_l" type="number" step="any" value="6"/></div>
    </div>
  `)
});

$("btnAddCircPatch").onclick = ()=>openModal({
  title: "Add circular section (patch): thickness override + pressure",
  kind:"patch", shape:"circle",
  html: modalHtmlBase(`
    <div style="margin-top:10px;">
      <label>Radius (r)</label>
      <input id="f_r" type="number" step="any" value="3"/>
    </div>
    <div class="grid2" style="margin-top:10px;">
      <div><label>Override thickness (t')</label><input id="f_tO" type="number" step="any" value="0.4"/></div>
      <div><label>Pressure (p)</label><input id="f_p" type="number" step="any" value="0"/></div>
    </div>
  `)
});

$("btnAddRectPatch").onclick = ()=>openModal({
  title: "Add rectangular section (patch): thickness override + pressure",
  kind:"patch", shape:"rect",
  html: modalHtmlBase(`
    <div class="grid2" style="margin-top:10px;">
      <div><label>Width (w)</label><input id="f_w" type="number" step="any" value="6"/></div>
      <div><label>Length (l)</label><input id="f_l" type="number" step="any" value="4"/></div>
    </div>
    <div class="grid2" style="margin-top:10px;">
      <div><label>Override thickness (t')</label><input id="f_tO" type="number" step="any" value="0.35"/></div>
      <div><label>Pressure (p)</label><input id="f_p" type="number" step="any" value="0"/></div>
    </div>
  `)
});

/***********************
 * Picking BC (use BC tubes group)
 ***********************/
function onPointerDown(ev){
  const rect = canvas.getBoundingClientRect();
  const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
  mouse.set(x,y);
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(grpBC.children, true);
  if (!hits.length){
    pickedLabel.textContent = "(none)";
    selectedBoundaryId = null;
    selBoundary.value = "(none)";
    bcType.disabled = true;
    btnApplyBC.disabled = true;
    return;
  }

  const obj = hits[0].object;
  const ud = obj.userData || obj.parent?.userData || {};
  if (ud.pickType === "boundary"){
    selectedBoundaryId = ud.boundaryId;
    pickedLabel.textContent = ud.boundaryLabel || selectedBoundaryId;
    selBoundary.value = ud.boundaryLabel || selectedBoundaryId;

    bcType.disabled = false;
    btnApplyBC.disabled = false;
    bcType.value = model.bcs[selectedBoundaryId] || "free";
  }
}
canvas.addEventListener("pointerdown", onPointerDown);

btnApplyBC.onclick = ()=>{
  if (!selectedBoundaryId) return;
  model.bcs[selectedBoundaryId] = bcType.value;
  // recolor BC tubes + boundary wire overlay by rebuilding visuals
  buildAll();
};

/***********************
 * Sync inputs
 ***********************/
function syncInputsToModel(){
  model.units = units.value;
  model.shape.type = shapeType.value;

  const W = Number($("W").value);
  const L = Number($("L").value);
  const D = Number($("D").value);
  const t = Number($("t").value);
  const E = Number($("E").value);
  const rho = Number($("rho").value);
  const h = Number($("h").value);

  if (isFinite(W)) model.shape.W = W;
  if (isFinite(L)) model.shape.L = L;
  if (isFinite(D)) model.shape.D = D;
  if (isFinite(t)) model.shape.t = t;
  if (isFinite(E)) model.shape.E = E;
  if (isFinite(rho)) model.shape.rho = rho;
  if (isFinite(h) && h>0) model.shape.h = h;
}

shapeType.onchange = ()=>{
  const isRect = shapeType.value === "rect";
  rectDims.style.display = isRect ? "block" : "none";
  circDims.style.display = isRect ? "none" : "block";
};

$("btnBuild").onclick = ()=>{
  syncInputsToModel();
  showErr("");
  selectedBoundaryId = null;
  selBoundary.value = "(none)";
  bcType.disabled = true;
  btnApplyBC.disabled = true;
  buildAll();
};

/***********************
 * Boundary IDs (outer + cutouts)
 ***********************/
function ensureDefaultBC(boundaryId){
  if (!model.bcs[boundaryId]) model.bcs[boundaryId] = "free";
}

/***********************
 * Geometry discretization (polylines) tied to h
 ***********************/
function discretizeCircle(cx, cy, r, h, alpha=1.2){
  const Nraw = Math.ceil((2*Math.PI*r) / (alpha*h));
  const N = Math.max(32, Math.min(512, Nraw));
  const pts = [];
  for (let i=0;i<N;i++){
    const th = (i/N)*Math.PI*2;
    pts.push({x: cx + r*Math.cos(th), y: cy + r*Math.sin(th)});
  }
  return pts;
}

function discretizeRect(cx, cy, w, l, h){
  const x0 = cx - w/2, x1 = cx + w/2;
  const y0 = cy - l/2, y1 = cy + l/2;

  // points on each edge at spacing ~h
  const pts = [];
  const pushEdge = (ax,ay,bx,by)=>{
    const L = Math.hypot(bx-ax, by-ay);
    const n = Math.max(1, Math.ceil(L / h));
    for (let i=0;i<n;i++){
      const t = i/n;
      pts.push({x: ax + t*(bx-ax), y: ay + t*(by-ay)});
    }
  };

  // CCW
  pushEdge(x0,y0, x1,y0);
  pushEdge(x1,y0, x1,y1);
  pushEdge(x1,y1, x0,y1);
  pushEdge(x0,y1, x0,y0);

  return pts;
}

function outerLoop(h){
  if (model.shape.type==="rect"){
    return discretizeRect(0,0, model.shape.W, model.shape.L, h);
  }
  return discretizeCircle(0,0, model.shape.D/2, h);
}

function featureLoop(f, h){
  if (f.shape==="circle") return discretizeCircle(f.cx, f.cy, f.r, h);
  return discretizeRect(f.cx, f.cy, f.w, f.l, h);
}

/***********************
 * Mesh generation (poly2tri)
 * Conforming patches by:
 *  - base triangulation with cutouts + patches as HOLES
 *  - each patch triangulated separately (no holes)
 *  - shared boundary points (same coordinates) -> we unify points by snapping keys
 ***********************/
function buildMesh(){
  const h = model.shape.h;

  // crude guardrail
  const span = spanVal();
  if (h < span/300) { throw new Error(`h is very small. Use h ≥ ${fmt(span/300)} to avoid huge meshes.`); }
  if (h > span/6)   { throw new Error(`h is very large. Use h ≤ ${fmt(span/6)} for a meaningful mesh.`); }

  const epsSnap = Math.max(1e-9, 0.001*epsilon()); // snapping for shared points

  const keyOf = (x,y)=>`${Math.round(x/epsSnap)}_${Math.round(y/epsSnap)}`;

  // global point registry (poly2tri.Point) so shared boundaries reuse coordinates consistently
  const pointMap = new Map(); // key -> {pt, idx, x, y}
  const V = [];

  function getPoint(x,y){
    const k = keyOf(x,y);
    let rec = pointMap.get(k);
    if (!rec){
      const pt = new poly2tri.Point(x,y);
      rec = { pt, idx: V.length, x, y };
      pointMap.set(k, rec);
      V.push({x,y});
    }
    return rec.pt;
  }

  function loopToPts(loop){
    // poly2tri wants array of Points; loop is open list; we pass as contour (implicitly closed)
    return loop.map(p => getPoint(p.x, p.y));
  }

  // Build loops
  const OUT = outerLoop(h);

  const cutouts = model.features.filter(f=>f.kind==="cutout");
  const patches = model.features.filter(f=>f.kind==="patch");

  const CUT_LOOPS = cutouts.map(f => ({ id:`cutout:${f.id}`, f, loop: featureLoop(f,h) }));
  const PATCH_LOOPS = patches.map(f => ({ id:`patch:${f.id}`, f, loop: featureLoop(f,h) }));

  // Ensure BC ids exist: outer + each cutout
  if (model.shape.type==="rect"){
    ["outer:edge:0","outer:edge:1","outer:edge:2","outer:edge:3"].forEach(ensureDefaultBC);
  } else {
    ensureDefaultBC("outer:perimeter");
  }
  CUT_LOOPS.forEach(c => ensureDefaultBC(c.id));

  // poly2tri base triangulation
  const baseContour = loopToPts(OUT);
  const swBase = new poly2tri.SweepContext(baseContour);

  // holes: cutouts + patches (patch as hole in base)
  CUT_LOOPS.forEach(c => swBase.addHole(loopToPts(c.loop)));
  PATCH_LOOPS.forEach(p => swBase.addHole(loopToPts(p.loop)));

  // interior steiner points: light grid to encourage sizing
  // (Simple, fast; poly2tri doesn't do strict area constraints)
  const A = (model.shape.type==="rect") ? (model.shape.W*model.shape.L) : (Math.PI*(model.shape.D/2)**2);
  const estTris = A / (0.6*h*h);
  if (estTris > 80000) throw new Error(`Requested mesh may be too large (estimated ~${Math.round(estTris)} tris). Increase h.`);

  // Seed interior points on coarse grid, excluding holes and patches and outside
  const seeds = buildInteriorSeeds(h, OUT, CUT_LOOPS.map(x=>x.loop), PATCH_LOOPS.map(x=>x.loop));
  seeds.forEach(p => swBase.addPoint(getPoint(p.x,p.y)));

  swBase.triangulate();
  const baseTris = swBase.getTriangles();

  // Triangulate each patch separately
  const patchTrisById = new Map();
  for (const P of PATCH_LOOPS){
    const swP = new poly2tri.SweepContext(loopToPts(P.loop));
    // optional seed points inside patch (helps sizing)
    const s2 = buildInteriorSeeds(h, P.loop, [], []);
    s2.forEach(p => swP.addPoint(getPoint(p.x,p.y)));
    swP.triangulate();
    patchTrisById.set(P.id, swP.getTriangles());
  }

  // Convert poly2tri triangles to index triples
  const T = [];
  function pushTri(tri, regionId){
    const pts = tri.getPoints(); // [Point,Point,Point]
    const idx = pts.map(pt => {
      // reverse lookup by snapping coordinate
      const k = keyOf(pt.x, pt.y);
      const rec = pointMap.get(k);
      if (!rec) throw new Error("Internal point mapping error.");
      return rec.idx;
    });
    T.push({ i1: idx[0], i2: idx[1], i3: idx[2], region: regionId });
  }

  baseTris.forEach(tri => pushTri(tri, "base"));
  for (const [pid, tris] of patchTrisById.entries()){
    tris.forEach(tri => pushTri(tri, pid));
  }

  // Region properties
  const regions = { base: { t: model.shape.t, p: 0 } };
  PATCH_LOOPS.forEach(p => {
    regions[p.id] = { t: p.f.tOverride, p: p.f.pressure };
  });

  // Boundary segments (for BC tubes + edge grouping)
  const loops = {
    outer: OUT,
    cutouts: CUT_LOOPS.map(c => ({ id:c.id, loop:c.loop })),
    patches: PATCH_LOOPS.map(p => ({ id:p.id, loop:p.loop }))
  };

  return { V, T, regions, loops };
}

// Build interior steiner seeds (cheap)
function buildInteriorSeeds(h, outer, holes, patchHoles){
  // We treat holes array as exclusions.
  const span = spanVal();
  const step = 1.25*h;
  const pts = [];

  // Bounding box from outer loop
  let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
  outer.forEach(p=>{ xmin=Math.min(xmin,p.x); ymin=Math.min(ymin,p.y); xmax=Math.max(xmax,p.x); ymax=Math.max(ymax,p.y); });

  // quick point-in-poly
  const pip = (pt, poly)=>{
    let inside=false;
    for (let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y;
      const xj=poly[j].x, yj=poly[j].y;
      const intersect = ((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-30)+xi);
      if (intersect) inside=!inside;
    }
    return inside;
  };

  for (let y=ymin+step*0.5; y<=ymax-step*0.5; y+=step){
    for (let x=xmin+step*0.5; x<=xmax-step*0.5; x+=step){
      const p={x,y};
      if (!pip(p, outer)) continue;
      // exclude cutouts + patch holes
      let bad=false;
      for (const H of holes){ if (pip(p,H)) { bad=true; break; } }
      if (bad) continue;
      for (const H of patchHoles){ if (pip(p,H)) { bad=true; break; } }
      if (bad) continue;
      pts.push(p);
    }
  }

  // keep it reasonable
  const maxSeeds = 5000;
  if (pts.length > maxSeeds) return pts.slice(0, maxSeeds);
  return pts;
}

/***********************
 * Rendering: extruded triangle prisms + wire + BC tubes + loads
 ***********************/
function renderMesh3D(meshObj){
  clearGroup(grpSolid);
  clearGroup(grpWire);
  clearGroup(grpBC);
  clearGroup(grpLoads);

  if (!meshObj){ meshStats.textContent="—"; return; }

  const V = meshObj.V;
  const T = meshObj.T;
  const regions = meshObj.regions;
  const tBase = regions.base.t;

  meshStats.textContent = `${V.length} nodes • ${T.length} tris`;

  // --- Materials per region
  const mats = new Map();
  function matFor(regionId){
    if (mats.has(regionId)) return mats.get(regionId);
    const isBase = regionId === "base";
    const m = new THREE.MeshStandardMaterial({
      color: isBase ? 0xdbe6ff : 0x22c55e,
      transparent: true,
      opacity: 0.92,
      roughness: 0.9,
      metalness: 0.05
    });
    mats.set(regionId, m);
    return m;
  }

  // --- Build prism geometry per region (batched)
  const buckets = new Map(); // regionId -> {pos:[], idx:[]}
  function bucket(regionId){
    if (!buckets.has(regionId)) buckets.set(regionId, {pos:[], idx:[]});
    return buckets.get(regionId);
  }

  // Helper add prism for one triangle into region bucket
  function addTriPrism(regionId, i1,i2,i3){
    const tElem = regions[regionId].t;

    const b = bucket(regionId);
    const baseIndex = b.pos.length / 3;

    const p1 = V[i1], p2 = V[i2], p3 = V[i3];

    // bottom vertices
    b.pos.push(p1.x, 0, p1.y);
    b.pos.push(p2.x, 0, p2.y);
    b.pos.push(p3.x, 0, p3.y);

    // top vertices
    b.pos.push(p1.x, tElem, p1.y);
    b.pos.push(p2.x, tElem, p2.y);
    b.pos.push(p3.x, tElem, p3.y);

    const b1=baseIndex+0, b2=baseIndex+1, b3=baseIndex+2;
    const t1=baseIndex+3, t2=baseIndex+4, t3=baseIndex+5;

    // top face
    b.idx.push(t1,t2,t3);
    // bottom face (reverse)
    b.idx.push(b3,b2,b1);

    // sides (each edge -> quad -> two tris)
    // edge 1-2
    b.idx.push(b1,b2,t2); b.idx.push(b1,t2,t1);
    // edge 2-3
    b.idx.push(b2,b3,t3); b.idx.push(b2,t3,t2);
    // edge 3-1
    b.idx.push(b3,b1,t1); b.idx.push(b3,t1,t3);
  }

  T.forEach(tri => addTriPrism(tri.region, tri.i1, tri.i2, tri.i3));

  // Create meshes
  for (const [rid, b] of buckets.entries()){
    const g = new THREE.BufferGeometry();
    g.setAttribute("position", new THREE.Float32BufferAttribute(b.pos, 3));
    g.setIndex(b.idx);
    g.computeVertexNormals();
    const m = matFor(rid);
    const mesh = new THREE.Mesh(g, m);
    grpSolid.add(mesh);
  }

  // --- Wireframe on top surfaces (simple; duplicates ok)
  const wirePos = [];
  const lift = 0.002 * Math.max(1, tBase);

  function triTopY(regionId){
    return regions[regionId].t + lift;
  }

  T.forEach(tri=>{
    const y = triTopY(tri.region);
    const a = V[tri.i1], b = V[tri.i2], c = V[tri.i3];
    // edges a-b, b-c, c-a
    wirePos.push(a.x,y,a.y, b.x,y,b.y);
    wirePos.push(b.x,y,b.y, c.x,y,c.y);
    wirePos.push(c.x,y,c.y, a.x,y,a.y);
  });

  const wireGeo = new THREE.BufferGeometry();
  wireGeo.setAttribute("position", new THREE.Float32BufferAttribute(wirePos, 3));
  const wireMat = new THREE.LineBasicMaterial({ color: 0x94a3b8, transparent:true, opacity:0.65 });
  const wire = new THREE.LineSegments(wireGeo, wireMat);
  grpWire.add(wire);

  // --- BC clickable tubes (outer + cutouts only)
  addBCTubes(meshObj);

  // --- Loads: pressure arrows on patch regions
  addPressureArrows(meshObj);

  // Frame camera
  const span = spanVal();
  controls.target.set(0, 0, 0);
  camera.position.set(span*1.2, span*0.9, span*1.5);
  controls.update();
}

function addBCTubes(meshObj){
  const tMax = Math.max(...Object.values(meshObj.regions).map(r=>r.t));
  const y = tMax + 0.01;

  // tube radius depends on span
  const span = spanVal();
  const r = Math.max(0.003*span, 0.04*model.shape.h);

  // Outer boundaries
  if (model.shape.type==="rect"){
    // build 4 tubes from conceptual outer edges
    const W=model.shape.W, L=model.shape.L;
    const edges = [
      { id:"outer:edge:0", label:"Outer edge +X", a:[ W/2, y, -L/2], b:[ W/2, y,  L/2] },
      { id:"outer:edge:1", label:"Outer edge -X", a:[-W/2, y, -L/2], b:[-W/2, y,  L/2] },
      { id:"outer:edge:2", label:"Outer edge +Z", a:[-W/2, y,  L/2], b:[ W/2, y,  L/2] },
      { id:"outer:edge:3", label:"Outer edge -Z", a:[-W/2, y, -L/2], b:[ W/2, y, -L/2] },
    ];
    edges.forEach(e=> addTubeForSegment(e.id,e.label,e.a,e.b,r, bcColor(model.bcs[e.id]||"free")));
  } else {
    const id="outer:perimeter";
    addTubeForPolyline(id, "Outer perimeter", meshObj.loops.outer, y, r, bcColor(model.bcs[id]||"free"));
  }

  // Cutouts (one BC per cutout loop)
  meshObj.loops.cutouts.forEach(c=>{
    addTubeForPolyline(c.id, `Cutout ${c.id.replace("cutout:","")} perimeter`, c.loop, y, r, bcColor(model.bcs[c.id]||"free"));
  });
}

function addTubeForSegment(boundaryId, boundaryLabel, a, b, radius, color){
  ensureDefaultBC(boundaryId);

  const p0 = new THREE.Vector3(a[0],a[1],a[2]);
  const p1 = new THREE.Vector3(b[0],b[1],b[2]);
  const curve = new THREE.LineCurve3(p0,p1);
  const geo = new THREE.TubeGeometry(curve, 8, radius, 10, false);
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.85, metalness:0.0 });
  const tube = new THREE.Mesh(geo, mat);
  tube.userData = { pickType:"boundary", boundaryId, boundaryLabel };
  grpBC.add(tube);
}

function addTubeForPolyline(boundaryId, boundaryLabel, loop, y, radius, color){
  ensureDefaultBC(boundaryId);

  // create closed Catmull path from loop points
  const pts = loop.map(p=>new THREE.Vector3(p.x, y, p.y));
  pts.push(new THREE.Vector3(loop[0].x, y, loop[0].y));
  const curve = new THREE.CatmullRomCurve3(pts, false);
  const geo = new THREE.TubeGeometry(curve, 160, radius, 10, false);
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.85, metalness:0.0 });
  const tube = new THREE.Mesh(geo, mat);
  tube.userData = { pickType:"boundary", boundaryId, boundaryLabel };
  grpBC.add(tube);
}

function addPressureArrows(meshObj){
  // draw arrows for patch regions only
  const V = meshObj.V;
  const T = meshObj.T;
  const regions = meshObj.regions;

  const span = spanVal();
  const baseLen = Math.max(0.05*span, 0.8*model.shape.h);

  // one arrow per ~k triangles in patch
  const k = 25;

  let count = 0;
  T.forEach((tri, idx)=>{
    if (tri.region === "base") return;
    const p = regions[tri.region].p;
    if (!isFinite(p) || Math.abs(p) < 1e-12) return;
    if ((idx % k) !== 0) return;

    const a=V[tri.i1], b=V[tri.i2], c=V[tri.i3];
    const xc = (a.x+b.x+c.x)/3;
    const zc = (a.y+b.y+c.y)/3;

    const tElem = regions[tri.region].t;
    const origin = new THREE.Vector3(xc, tElem + 0.02, zc);

    const mag = Math.min(3.0, Math.max(0.6, Math.log10(1 + Math.abs(p)) + 0.6));
    const len = baseLen * mag;

    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,-1,0), origin, len, 0xf59e0b, 0.25*len, 0.15*len);
    grpLoads.add(arrow);
    count++;
  });

  // optional: could display count in HUD later
}

/***********************
 * Build all: validate -> mesh -> render
 ***********************/
function buildAll(){
  renderFeatureList();
  showErr("");

  // ensure h is sane enough
  const span = spanVal();
  if (!(model.shape.h > 0)){
    showErr("Target element size h must be > 0.");
    return;
  }

  // regenerate mesh
  try{
    mesh = buildMesh();
  } catch(e){
    mesh = null;
    clearGroup(grpSolid); clearGroup(grpWire); clearGroup(grpBC); clearGroup(grpLoads);
    meshStats.textContent = "—";
    showErr(e?.message || String(e));
    return;
  }

  renderMesh3D(mesh);
}

/***********************
 * Export / Reset
 ***********************/
$("btnExport").onclick = ()=>{
  syncInputsToModel();
  const out = {
    model,
    mesh
  };
  const blob = new Blob([JSON.stringify(out, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "plate_model_with_mesh.json";
  a.click();
  URL.revokeObjectURL(url);
};

$("btnReset").onclick = ()=>location.reload();

/***********************
 * Init
 ***********************/
syncInputsToModel();
renderFeatureList();
buildAll();
resize();

function animate(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

</script>
</body>
</html>






<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Plate Module UI — 6-Noded FE (UI First)</title>


<!-- Three.js (module) -->
<style>
  :root{
    --W: 900px;
    --panel-bg: #f5f7fb;
    --card: #ffffff;
    --ink: #0b1220;
    --muted: #5b6678;
    --border: #d7dde6;
    --blue: #2563eb;
    --green: #16a34a;
    --amber: #f59e0b;
    --red: #dc2626;

    --free:  #6b7280;   /* gray */
    --ss:    #2563eb;   /* blue */
    --fixed: #dc2626;   /* red  */
  }

  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--ink);
    background: #fff;
  }

  /* Module wrapper constrained to 900px */
  .xl4-wrap{
    width: var(--W);
    margin: 16px auto;
    border: 1px solid var(--border);
    background: var(--panel-bg);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
  }

  .xl4-head{
    padding: 14px 16px;
    background: linear-gradient(90deg, #0b1220, #111c33);
    color: #fff;
    display:flex;
    align-items:center;
    justify-content: space-between;
  }
  .xl4-title{
    font-weight: 900;
    letter-spacing: -0.02em;
  }
  .xl4-sub{
    font-size: 12px;
    opacity: 0.85;
    margin-top: 2px;
  }

  .xl4-body{
    display:grid;
    grid-template-columns: 330px 1fr;
    gap: 12px;
    padding: 12px;
  }

  .card{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
  }

  .section-title{
    font-weight: 850;
    letter-spacing: -0.01em;
    margin: 0 0 8px 0;
    font-size: 14px;
  }

  .grid2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  label{
    display:block;
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 4px;
  }

  input, select{
    width:100%;
    padding: 8px 9px;
    border: 1px solid var(--border);
    border-radius: 10px;
    font-size: 13px;
    outline: none;
    background: #fff;
  }
  input:focus, select:focus{
    border-color: #9db7ff;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
  }

  .row{
    display:flex;
    gap: 8px;
    align-items:center;
  }

  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    border: 1px solid var(--border);
    background: #fff;
    color: var(--ink);
    padding: 9px 10px;
    border-radius: 12px;
    font-weight: 750;
    cursor:pointer;
    user-select:none;
    font-size: 13px;
  }
  .btn:hover{ border-color:#b8c3d6; }
  .btn.primary{
    background: var(--blue);
    color:#fff;
    border-color: var(--blue);
  }
  .btn.primary:hover{ filter: brightness(0.98); }
  .btn.danger{
    background: var(--red);
    color:#fff;
    border-color: var(--red);
  }
  .btn.small{
    padding: 6px 8px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 750;
  }

  .list{
    margin: 0;
    padding: 0;
    list-style: none;
    display:flex;
    flex-direction:column;
    gap: 8px;
  }

  .item{
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px;
    background: #fff;
  }

  .item-top{
    display:flex;
    align-items:flex-start;
    justify-content: space-between;
    gap: 10px;
  }

  .pill{
    font-size: 11px;
    font-weight: 800;
    border-radius: 999px;
    padding: 4px 8px;
    border: 1px solid var(--border);
    color: var(--muted);
    background: #f8fafc;
  }
  .muted{ color: var(--muted); font-size: 12px; }

.canvasWrap{
  background:#ffffff;
  border-radius: 12px;
  border: 1px solid var(--border);
  overflow:hidden;
  position: relative;
  min-height: 560px;
}
  #gl{
    width: 100%;
    height: 560px;
    display:block;
  }

  .hud{
    position:absolute;
    left: 10px;
    top: 10px;
    background: rgba(255,255,255,0.92);
    border: 1px solid rgba(215,221,230,0.9);
    border-radius: 12px;
    padding: 10px;
    width: 280px;
  }
  .hud .k{
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 4px;
  }
  .hud .v{
    font-size: 12px;
    font-weight: 800;
  }

  .legend{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 8px;
  }
  .leg{
    display:flex; align-items:center; gap:6px;
    font-size: 11px; color: var(--muted); font-weight: 700;
  }
  .dot{ width:10px; height:10px; border-radius: 50%; display:inline-block; }
  .dot.free{ background: var(--free); }
  .dot.ss{ background: var(--ss); }
  .dot.fixed{ background: var(--fixed); }

  /* Simple modal */
  .modalBackdrop{
    position: fixed;
    inset: 0;
    background: rgba(11, 18, 32, 0.55);
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 50;
    padding: 20px;
  }
  .modal{
    width: min(560px, 100%);
    background: #fff;
    border-radius: 14px;
    border: 1px solid var(--border);
    box-shadow: 0 22px 60px rgba(0,0,0,0.25);
    overflow:hidden;
  }
  .modalHead{
    padding: 12px 14px;
    background: #f8fafc;
    border-bottom: 1px solid var(--border);
    display:flex;
    justify-content: space-between;
    align-items:center;
    gap: 10px;
  }
  .modalTitle{
    font-weight: 900;
    letter-spacing: -0.02em;
  }
  .modalBody{ padding: 14px; }
  .modalFoot{
    padding: 12px 14px;
    border-top: 1px solid var(--border);
    display:flex;
    justify-content:flex-end;
    gap: 8px;
    background:#fff;
  }
</style>
</head>

<body>
<div class="xl4-wrap">
  <div class="xl4-head">
    <div>
      <div class="xl4-title">Plate Module — UI & 3D Boundary Conditions</div>
      <div class="xl4-sub">Next step: 6-noded FE meshing + plate stiffness/pressure solve</div>
    </div>
    <div class="row">
      <button class="btn small" id="btnExport">Export JSON</button>
      <button class="btn small danger" id="btnReset">Reset</button>
    </div>
  </div>

  <div class="xl4-body">
    <!-- LEFT PANEL -->
    <div class="card">
      <div class="section-title">Overall geometry</div>

      <div class="grid2">
        <div>
          <label>Overall shape</label>
          <select id="shapeType">
            <option value="rect">Rectangular</option>
            <option value="circle">Circular</option>
          </select>
        </div>
        <div>
          <label>Units (label only for now)</label>
          <select id="units">
            <option value="in-lbf">in / lbf</option>
            <option value="m-n">m / N</option>
          </select>
        </div>
      </div>

      <div id="rectDims" style="margin-top:10px;">
        <div class="grid2">
          <div>
            <label>Width (W)</label>
            <input id="W" type="number" step="any" value="20"/>
          </div>
          <div>
            <label>Length (L)</label>
            <input id="L" type="number" step="any" value="30"/>
          </div>
        </div>
      </div>

      <div id="circDims" style="margin-top:10px; display:none;">
        <div>
          <label>Diameter (D)</label>
          <input id="D" type="number" step="any" value="24"/>
        </div>
      </div>

      <div style="margin-top:10px;" class="grid2">
        <div>
          <label>Thickness (t)</label>
          <input id="t" type="number" step="any" value="0.25"/>
        </div>
        <div>
          <label>Modulus (E)</label>
          <input id="E" type="number" step="any" value="30000000"/>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label>Material weight density (ρ) (e.g., lbf/in³ or N/m³)</label>
        <input id="rho" type="number" step="any" value="0.283"/>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnBuild">Build / Update Model</button>
      </div>

      <hr style="border:none;border-top:1px solid var(--border); margin:12px 0;" />

      <div class="section-title">Features</div>
      <div class="row" style="flex-wrap:wrap; gap:8px;">
        <button class="btn" id="btnAddCircCut">+ Circular cutout</button>
        <button class="btn" id="btnAddRectCut">+ Rectangular cutout</button>
        <button class="btn" id="btnAddCircPatch">+ Circular section (patch)</button>
        <button class="btn" id="btnAddRectPatch">+ Rectangular section (patch)</button>
      </div>

      <div style="margin-top:12px;">
        <div class="section-title">Feature list</div>
        <ul class="list" id="featureList"></ul>
        <div class="muted" id="featureEmpty">No features yet.</div>
      </div>

      <hr style="border:none;border-top:1px solid var(--border); margin:12px 0;" />

      <div class="section-title">Boundary conditions</div>
      <div class="muted">
        Click a boundary line in the 3D view. Then set BC below:
      </div>

      <div style="margin-top:10px;" class="grid2">
        <div>
          <label>Selected boundary</label>
          <input id="selBoundary" type="text" value="(none)" readonly />
        </div>
        <div>
          <label>BC type</label>
          <select id="bcType" disabled>
            <option value="free">Free</option>
            <option value="ss">Simply supported</option>
            <option value="fixed">Fixed</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnApplyBC" disabled>Apply BC</button>
      </div>

      <div class="muted" style="margin-top:8px;">
        Note: Circle currently exposes the outer perimeter as one selectable boundary. Rectangle has 4 edges.
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="canvasWrap">
      <canvas id="gl"></canvas>

      <div class="hud">
        <div class="k">Mouse</div>
        <div class="v">Left-drag rotate • Wheel zoom • Right-drag pan</div>

        <div class="legend">
          <div class="leg"><span class="dot free"></span> Free</div>
          <div class="leg"><span class="dot ss"></span> Simply supported</div>
          <div class="leg"><span class="dot fixed"></span> Fixed</div>
        </div>

        <div style="margin-top:10px;">
          <div class="k">Picked object</div>
          <div class="v" id="pickedLabel">(none)</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modalBackdrop" id="modalBackdrop">
  <div class="modal">
    <div class="modalHead">
      <div class="modalTitle" id="modalTitle">Add feature</div>
      <button class="btn small" id="btnModalClose">Close</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalFoot">
      <button class="btn" id="btnModalCancel">Cancel</button>
      <button class="btn primary" id="btnModalSave">Save</button>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>


<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  /***********************
   * Data model (UI stage)
   ***********************/
  const model = {
    units: "in-lbf",
    shape: {
      type: "rect", // 'rect' | 'circle'
      W: 20,
      L: 30,
      D: 24,
      t: 0.25,
      E: 30000000,
      rho: 0.283
    },
    // features: cutouts and patches
    features: [
      // { id, kind:'cutout'|'patch', shape:'circle'|'rect', cx, cy, r, w, l, tOverride?, pressure? }
    ],
    // boundary conditions: map boundaryId -> 'free'|'ss'|'fixed'
    bcs: {
      // outer edges:
      // rect edges: 'outer:edge:0..3'
      // circle: 'outer:perimeter'
    }
  };

  /***********************
   * DOM
   ***********************/
  const $ = (id) => document.getElementById(id);

  const shapeType = $("shapeType");
  const units = $("units");
  const rectDims = $("rectDims");
  const circDims = $("circDims");
  const featureList = $("featureList");
  const featureEmpty = $("featureEmpty");

  const selBoundary = $("selBoundary");
  const bcType = $("bcType");
  const btnApplyBC = $("btnApplyBC");
  const pickedLabel = $("pickedLabel");

  /***********************
   * Three.js scene
   ***********************/
  const canvas = $("gl");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

  const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 5000);
  camera.position.set(40, 35, 55);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.target.set(0, 0, 0);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 0.85);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(40, 70, 20);
  scene.add(dir);

  // helpers
  const grid = new THREE.GridHelper(120, 24, 0xb8c3d6, 0xe5eaf2);
  grid.position.y = -0.001;
  scene.add(grid);

  const axes = new THREE.AxesHelper(20);
  scene.add(axes);

  // groups for rebuilding
  const grpPlate = new THREE.Group(); scene.add(grpPlate);
  const grpEdges = new THREE.Group(); scene.add(grpEdges);
  const grpFeatures = new THREE.Group(); scene.add(grpFeatures);

  // picking
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let selectedBoundaryId = null;

  function bcColor(bc){
    if (bc === "fixed") return 0xdc2626;
    if (bc === "ss") return 0x2563eb;
    return 0x6b7280; // free default
  }

  function resize(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize);

  /***********************
   * Build visuals
   ***********************/
  function clearGroup(g){
    while (g.children.length){
      const obj = g.children.pop();
      obj.traverse?.((c) => {
        if (c.geometry) c.geometry.dispose?.();
        if (c.material){
          if (Array.isArray(c.material)) c.material.forEach(m => m.dispose?.());
          else c.material.dispose?.();
        }
      });
    }
  }

function buildPlate(){
  clearGroup(grpPlate);
  clearGroup(grpEdges);
  clearGroup(grpFeatures);

  const t = model.shape.t;

  // --- Materials
  const plateMat = new THREE.MeshStandardMaterial({
    color: 0xdbe6ff,
    metalness: 0.05,
    roughness: 0.9,
    transparent: true,
    opacity: 0.92
  });

  const cutEdgeMat = new THREE.LineBasicMaterial({ color: 0x111827 });

  const patchMat = new THREE.MeshStandardMaterial({
    color: 0x22c55e,
    transparent: true,
    opacity: 0.35,
    roughness: 0.85
  });

  const patchMatRecess = new THREE.MeshStandardMaterial({
    color: 0x60a5fa, // blue-ish to distinguish recess
    transparent: true,
    opacity: 0.35,
    roughness: 0.85
  });

  // --- Build a base Shape with holes (cutouts only)
  const { shape, outerBoundaryBuilder } = buildBaseShapeAndHoles();

  // --- Extrude into thickness
  const extrude = new THREE.ExtrudeGeometry(shape, {
    depth: t,
    bevelEnabled: false,
    curveSegments: 96
  });

  // ExtrudeGeometry extrudes along +Z; rotate so thickness is along +Y
  extrude.rotateX(-Math.PI / 2); // Z -> Y
  // After rotate, plate occupies y=[0,t], x/z about the defined shape

  const plateMesh = new THREE.Mesh(extrude, plateMat);
  plateMesh.position.set(0, 0, 0);
  grpPlate.add(plateMesh);

  // --- Outer boundary clickable edges
  outerBoundaryBuilder(t);

  // --- Cutout boundary clickable edges (each cutout creates its own boundary entity)
  addCutoutBoundaries(t);

  // --- Patches: show thickness delta + pressure arrows
  addPatchesAndLoads(t, patchMat, patchMatRecess);

  // --- zoom framing
  const span = (model.shape.type==="rect") ? Math.max(model.shape.W, model.shape.L) : model.shape.D;
  controls.target.set(0, 0, 0);
  camera.position.set(span*1.2, span*0.9, span*1.5);
  controls.update();

  renderFeatureList();
  resize();
}

/* -----------------------------
   Helpers for buildPlate()
------------------------------*/

function buildBaseShapeAndHoles(){
  const t = model.shape.t;

  // Shape coordinates live in (x, z) but THREE.Shape uses (x, y).
  // We'll treat shape.y as "z".

  let base = new THREE.Shape();
  let outerBoundaryBuilder = null;

  if (model.shape.type === "rect"){
    const W = model.shape.W;
    const L = model.shape.L;

    // Rectangle centered at (0,0)
    base.moveTo(-W/2, -L/2);
    base.lineTo( W/2, -L/2);
    base.lineTo( W/2,  L/2);
    base.lineTo(-W/2,  L/2);
    base.lineTo(-W/2, -L/2);

    outerBoundaryBuilder = (tTop) => {
      // 4 clickable outer edges, like before
      const edgeData = [
        { id:"outer:edge:0", a:[ W/2, tTop+0.001, -L/2], b:[ W/2, tTop+0.001,  L/2], label:"Outer edge +X" },
        { id:"outer:edge:1", a:[-W/2, tTop+0.001, -L/2], b:[-W/2, tTop+0.001,  L/2], label:"Outer edge -X" },
        { id:"outer:edge:2", a:[-W/2, tTop+0.001,  L/2], b:[ W/2, tTop+0.001,  L/2], label:"Outer edge +Z" },
        { id:"outer:edge:3", a:[-W/2, tTop+0.001, -L/2], b:[ W/2, tTop+0.001, -L/2], label:"Outer edge -Z" }
      ];
      edgeData.forEach(ed => addBoundaryLine(ed.id, ed.label, ed.a, ed.b));
    };

  } else {
    const R = model.shape.D/2;

    base.absarc(0, 0, R, 0, Math.PI*2, false);

    outerBoundaryBuilder = (tTop) => {
      const id = "outer:perimeter";
      const label = "Outer perimeter";
      addBoundaryPolylineCircle(id, label, 0, 0, R, tTop+0.001, 160);
    };
  }

  // Add holes from CUTOUT features only
  model.features.forEach(f => {
    if (f.kind !== "cutout") return;

    const hole = new THREE.Path();

    if (f.shape === "circle"){
      hole.absarc(f.cx, f.cy, f.r, 0, Math.PI*2, true);
    } else {
      const w = f.w, l = f.l;
      const x0 = f.cx - w/2, x1 = f.cx + w/2;
      const y0 = f.cy - l/2, y1 = f.cy + l/2;

      hole.moveTo(x0, y0);
      hole.lineTo(x1, y0);
      hole.lineTo(x1, y1);
      hole.lineTo(x0, y1);
      hole.lineTo(x0, y0);
    }

    base.holes.push(hole);
  });

  return { shape: base, outerBoundaryBuilder };
}

function addBoundaryLine(boundaryId, boundaryLabel, a, b){
  if (!model.bcs[boundaryId]) model.bcs[boundaryId] = "free";

  const geom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(...a),
    new THREE.Vector3(...b)
  ]);

  const mat = new THREE.LineBasicMaterial({ color: bcColor(model.bcs[boundaryId]) });
  const line = new THREE.Line(geom, mat);
  line.userData = { pickType:"boundary", boundaryId, boundaryLabel };
  grpEdges.add(line);
}

function addBoundaryPolylineCircle(boundaryId, boundaryLabel, cx, cz, r, y, n=128){
  if (!model.bcs[boundaryId]) model.bcs[boundaryId] = "free";

  const pts = [];
  for (let i=0;i<=n;i++){
    const th = (i/n)*Math.PI*2;
    pts.push(new THREE.Vector3(
      cx + r*Math.cos(th),
      y,
      cz + r*Math.sin(th)
    ));
  }
  const g = new THREE.BufferGeometry().setFromPoints(pts);
  const m = new THREE.LineBasicMaterial({ color: bcColor(model.bcs[boundaryId]) });
  const line = new THREE.Line(g, m);
  line.userData = { pickType:"boundary", boundaryId, boundaryLabel };
  grpEdges.add(line);
}

function addCutoutBoundaries(tTop){
  model.features.forEach(f => {
    if (f.kind !== "cutout") return;

    // Each cutout gets its own selectable boundary id
    // Circle => one perimeter boundary
    // Rect   => 4 edges (so you can set different BC on each side if desired)
    if (f.shape === "circle"){
      const id = `cutout:${f.id}:perimeter`;
      const label = `Cutout ${f.id} perimeter`;
      addBoundaryPolylineCircle(id, label, f.cx, f.cy, f.r, tTop+0.001, 128);
    } else {
      const w = f.w, l = f.l;
      const x0 = f.cx - w/2, x1 = f.cx + w/2;
      const z0 = f.cy - l/2, z1 = f.cy + l/2;

      // edges: +X, -X, +Z, -Z relative to cutout
      addBoundaryLine(`cutout:${f.id}:edge:0`, `Cutout ${f.id} edge +X`, [x1, tTop+0.001, z0], [x1, tTop+0.001, z1]);
      addBoundaryLine(`cutout:${f.id}:edge:1`, `Cutout ${f.id} edge -X`, [x0, tTop+0.001, z0], [x0, tTop+0.001, z1]);
      addBoundaryLine(`cutout:${f.id}:edge:2`, `Cutout ${f.id} edge +Z`, [x0, tTop+0.001, z1], [x1, tTop+0.001, z1]);
      addBoundaryLine(`cutout:${f.id}:edge:3`, `Cutout ${f.id} edge -Z`, [x0, tTop+0.001, z0], [x1, tTop+0.001, z0]);
    }
  });
}

function addPatchesAndLoads(tBase, patchMat, patchMatRecess){
  model.features.forEach(f => {
    if (f.kind !== "patch") return;

    const tO = f.tOverride;
    const delta = tO - tBase;

    // 1) thickness visualization as raised or recessed "solid"
    if (Math.abs(delta) > 1e-9){
      const h = Math.abs(delta);
      const mat = (delta > 0) ? patchMat : patchMatRecess;

      let geom = null;
      if (f.shape === "circle"){
        // thin cylinder "plug"
        geom = new THREE.CylinderGeometry(f.r, f.r, h, 96, 1, false);
      } else {
        geom = new THREE.BoxGeometry(f.w, h, f.l);
      }

      const m = new THREE.Mesh(geom, mat);

      // Base plate occupies y=[0, tBase]. Its top is y=tBase.
      // For raised: place on top (center at tBase + h/2)
      // For recessed: place inside (center at tBase - h/2)
      const yCenter = (delta > 0) ? (tBase + h/2) : (tBase - h/2);
      m.position.set(f.cx, yCenter, f.cy);
      m.userData = { pickType:"feature", featureId: f.id };
      grpFeatures.add(m);
    } else {
      // If no thickness change, you can still show a faint patch region
      // (optional; keep as-is)
      const mat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        transparent: true,
        opacity: 0.25,
        roughness: 0.9
      });
      let geom = null;
      if (f.shape === "circle") geom = new THREE.CylinderGeometry(f.r, f.r, 0.02, 80);
      else geom = new THREE.BoxGeometry(f.w, 0.02, f.l);

      const m = new THREE.Mesh(geom, mat);
      m.position.set(f.cx, tBase + 0.01, f.cy);
      m.userData = { pickType:"feature", featureId: f.id };
      grpFeatures.add(m);
    }

    // 2) Pressure arrows (transverse)
    // Convention: positive pressure acts downward (-Y). Only draw if p != 0.
    const p = Number(f.pressure ?? 0);
    if (!isFinite(p) || Math.abs(p) < 1e-12) return;

    addPressureArrowsForPatch(f, tBase, p);
  });
}

function addPressureArrowsForPatch(f, tBase, p){
  // visual scaling for arrow length: make it visible but not huge
  const span = (model.shape.type==="rect") ? Math.max(model.shape.W, model.shape.L) : model.shape.D;
  const L = Math.max(0.06*span, 0.6*tBase); // keep visible for thin plates
  const dir = new THREE.Vector3(0, -1, 0);

  // Arrow color: amber
  const col = 0xf59e0b;

  // We’ll seed a small grid of arrows across the patch footprint
  const pts = [];

  if (f.shape === "circle"){
    const r = f.r;
    const nR = 3;     // rings
    const nT = 8;     // angles per ring
    // center arrow
    pts.push([f.cx, f.cy]);
    for (let ir=1; ir<=nR; ir++){
      const rr = (ir/(nR+0.2))*r*0.9;
      for (let it=0; it<nT; it++){
        const th = (it/nT)*Math.PI*2;
        pts.push([f.cx + rr*Math.cos(th), f.cy + rr*Math.sin(th)]);
      }
    }
  } else {
    const w = f.w, l = f.l;
    const nx = 4, nz = 3;
    for (let ix=0; ix<nx; ix++){
      const x = f.cx - w/2 + (ix+0.5)*w/nx;
      for (let iz=0; iz<nz; iz++){
        const z = f.cy - l/2 + (iz+0.5)*l/nz;
        pts.push([x, z]);
      }
    }
  }

  // Arrow origin slightly above the top surface so it doesn't z-fight
  const y0 = tBase + 0.02;

  // Optionally, scale arrowhead size with |p|, but clamp for sanity
  const mag = Math.min(3.0, Math.max(0.6, Math.log10(1 + Math.abs(p)) + 0.6));
  const len = L * mag;
  const headLen = 0.25 * len;
  const headWid = 0.15 * len;

  pts.forEach(([x, z]) => {
    const origin = new THREE.Vector3(x, y0, z);
    const arrow = new THREE.ArrowHelper(dir, origin, len, col, headLen, headWid);
    arrow.userData = { pickType:"feature", featureId: f.id };
    grpFeatures.add(arrow);
  });
}
  /***********************
   * Feature list UI
   ***********************/
  function fmt(n){
    if (typeof n !== "number" || !isFinite(n)) return "—";
    const a = Math.abs(n);
    if (a >= 1000) return n.toFixed(0);
    if (a >= 10) return n.toFixed(3).replace(/0+$/,'').replace(/\.$/,'');
    return n.toFixed(4).replace(/0+$/,'').replace(/\.$/,'');
  }

  function renderFeatureList(){
    featureList.innerHTML = "";
    featureEmpty.style.display = model.features.length ? "none" : "block";

    model.features.forEach(f => {
      const li = document.createElement("li");
      li.className = "item";

      const top = document.createElement("div");
      top.className = "item-top";

      const left = document.createElement("div");
      const kind = f.kind === "cutout" ? "Cutout" : "Section (patch)";
      const shape = f.shape === "circle" ? "Circle" : "Rect";
      left.innerHTML = `
        <div style="font-weight:900; letter-spacing:-0.01em;">${kind}: ${shape}</div>
        <div class="muted">Center (x,y) = (${fmt(f.cx)}, ${fmt(f.cy)})</div>
        <div class="muted">${featureDimsText(f)}</div>
        ${f.kind==="patch" ? `<div class="muted">tOverride=${fmt(f.tOverride)} • p=${fmt(f.pressure)}</div>` : ``}
      `;

      const right = document.createElement("div");
      right.style.display="flex";
      right.style.gap="6px";
      right.style.alignItems="center";
      right.innerHTML = `<span class="pill">${f.id}</span>`;

      const btnDel = document.createElement("button");
      btnDel.className = "btn small danger";
      btnDel.textContent = "Delete";
      btnDel.onclick = () => {
        model.features = model.features.filter(x => x.id !== f.id);
        buildPlate();
      };

      right.appendChild(btnDel);
      top.appendChild(left);
      top.appendChild(right);

      li.appendChild(top);
      featureList.appendChild(li);
    });
  }

  function featureDimsText(f){
    if (f.shape === "circle") return `r = ${fmt(f.r)}`;
    return `w × l = ${fmt(f.w)} × ${fmt(f.l)}`;
  }

  /***********************
   * Modal builder
   ***********************/
  const modalBackdrop = $("modalBackdrop");
  const modalTitle = $("modalTitle");
  const modalBody = $("modalBody");
  const btnModalClose = $("btnModalClose");
  const btnModalCancel = $("btnModalCancel");
  const btnModalSave = $("btnModalSave");

  let modalContext = null;

  function openModal(ctx){
    modalContext = ctx;
    modalTitle.textContent = ctx.title;
    modalBody.innerHTML = ctx.html;
    modalBackdrop.style.display = "flex";
  }
  function closeModal(){
    modalBackdrop.style.display = "none";
    modalContext = null;
  }

  btnModalClose.onclick = closeModal;
  btnModalCancel.onclick = closeModal;

  btnModalSave.onclick = () => {
    if (!modalContext) return;

    const read = (id) => {
      const el = document.getElementById(id);
      if (!el) return null;
      const v = Number(el.value);
      return isFinite(v) ? v : null;
    };

    const cx = read("f_cx");
    const cy = read("f_cy");
    if (cx === null || cy === null){
      alert("Please enter valid center location (x,y).");
      return;
    }

    const f = {
      id: `F${String(Date.now()).slice(-6)}`,
      kind: modalContext.kind,
      shape: modalContext.shape,
      cx, cy
    };

    if (modalContext.shape === "circle"){
      const r = read("f_r");
      if (r === null || r <= 0){ alert("Radius must be > 0."); return; }
      f.r = r;
    } else {
      const w = read("f_w");
      const l = read("f_l");
      if (w === null || l === null || w <= 0 || l <= 0){ alert("Width/Length must be > 0."); return; }
      f.w = w; f.l = l;
    }

    if (modalContext.kind === "patch"){
      const tO = read("f_tO");
      const p  = read("f_p");
      if (tO === null || tO <= 0){ alert("Override thickness must be > 0."); return; }
      if (p === null){ alert("Pressure must be a valid number (use 0 if none)."); return; }
      f.tOverride = tO;
      f.pressure = p;
    }

    model.features.push(f);
    closeModal();
    buildPlate();
  };

  function modalHtmlBase(extra){
    return `
      <div class="grid2">
        <div>
          <label>Center X</label>
          <input id="f_cx" type="number" step="any" value="0"/>
        </div>
        <div>
          <label>Center Y</label>
          <input id="f_cy" type="number" step="any" value="0"/>
        </div>
      </div>
      ${extra}
    `;
  }

  /***********************
   * Picking / BC assignment
   ***********************/
  function onPointerDown(ev){
    // compute normalized device coords
    const rect = canvas.getBoundingClientRect();
    const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
    mouse.set(x, y);

    raycaster.setFromCamera(mouse, camera);

    const pickables = [...grpEdges.children, ...grpFeatures.children];
    const hits = raycaster.intersectObjects(pickables, true);

    if (!hits.length){
      pickedLabel.textContent = "(none)";
      selectedBoundaryId = null;
      selBoundary.value = "(none)";
      bcType.disabled = true;
      btnApplyBC.disabled = true;
      return;
    }

    const obj = hits[0].object;
    const ud = obj.userData || obj.parent?.userData || {};
    if (ud.pickType === "boundary"){
      selectedBoundaryId = ud.boundaryId;
      pickedLabel.textContent = ud.boundaryLabel || selectedBoundaryId;
      selBoundary.value = ud.boundaryLabel || selectedBoundaryId;

      bcType.disabled = false;
      btnApplyBC.disabled = false;
      bcType.value = model.bcs[selectedBoundaryId] || "free";
    } else if (ud.pickType === "feature"){
      pickedLabel.textContent = `Feature ${ud.featureId}`;
      // leave BC selection unchanged
    } else {
      pickedLabel.textContent = "(picked)";
    }
  }

  canvas.addEventListener("pointerdown", onPointerDown);

  btnApplyBC.onclick = () => {
    if (!selectedBoundaryId) return;
    model.bcs[selectedBoundaryId] = bcType.value;
    buildPlate(); // rebuild to recolor edges
  };

  /***********************
   * Overall geometry inputs
   ***********************/
  function syncInputsToModel(){
    model.units = units.value;
    model.shape.type = shapeType.value;

    const W = Number($("W").value);
    const L = Number($("L").value);
    const D = Number($("D").value);
    const t = Number($("t").value);
    const E = Number($("E").value);
    const rho = Number($("rho").value);

    if (isFinite(W)) model.shape.W = W;
    if (isFinite(L)) model.shape.L = L;
    if (isFinite(D)) model.shape.D = D;
    if (isFinite(t)) model.shape.t = t;
    if (isFinite(E)) model.shape.E = E;
    if (isFinite(rho)) model.shape.rho = rho;
  }

  shapeType.onchange = () => {
    const isRect = shapeType.value === "rect";
    rectDims.style.display = isRect ? "block" : "none";
    circDims.style.display = isRect ? "none" : "block";
  };

  $("btnBuild").onclick = () => {
    syncInputsToModel();
    // clear boundary selection on rebuild
    selectedBoundaryId = null;
    selBoundary.value = "(none)";
    bcType.disabled = true;
    btnApplyBC.disabled = true;
    buildPlate();
  };

  /***********************
   * Feature buttons
   ***********************/
  $("btnAddCircCut").onclick = () => {
    openModal({
      title: "Add circular cutout",
      kind: "cutout",
      shape: "circle",
      html: modalHtmlBase(`
        <div style="margin-top:10px;">
          <label>Radius (r)</label>
          <input id="f_r" type="number" step="any" value="2"/>
        </div>
      `)
    });
  };

  $("btnAddRectCut").onclick = () => {
    openModal({
      title: "Add rectangular cutout",
      kind: "cutout",
      shape: "rect",
      html: modalHtmlBase(`
        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Width (w)</label>
            <input id="f_w" type="number" step="any" value="4"/>
          </div>
          <div>
            <label>Length (l)</label>
            <input id="f_l" type="number" step="any" value="6"/>
          </div>
        </div>
      `)
    });
  };

  $("btnAddCircPatch").onclick = () => {
    openModal({
      title: "Add circular section (patch): thickness override + pressure",
      kind: "patch",
      shape: "circle",
      html: modalHtmlBase(`
        <div style="margin-top:10px;">
          <label>Radius (r)</label>
          <input id="f_r" type="number" step="any" value="3"/>
        </div>
        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Override thickness (t')</label>
            <input id="f_tO" type="number" step="any" value="0.4"/>
          </div>
          <div>
            <label>Pressure (p)</label>
            <input id="f_p" type="number" step="any" value="0"/>
          </div>
        </div>
      `)
    });
  };

  $("btnAddRectPatch").onclick = () => {
    openModal({
      title: "Add rectangular section (patch): thickness override + pressure",
      kind: "patch",
      shape: "rect",
      html: modalHtmlBase(`
        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Width (w)</label>
            <input id="f_w" type="number" step="any" value="6"/>
          </div>
          <div>
            <label>Length (l)</label>
            <input id="f_l" type="number" step="any" value="4"/>
          </div>
        </div>
        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Override thickness (t')</label>
            <input id="f_tO" type="number" step="any" value="0.35"/>
          </div>
          <div>
            <label>Pressure (p)</label>
            <input id="f_p" type="number" step="any" value="0"/>
          </div>
        </div>
      `)
    });
  };

  /***********************
   * Export / Reset
   ***********************/
  $("btnExport").onclick = () => {
    syncInputsToModel();
    const blob = new Blob([JSON.stringify(model, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "plate_model_ui.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  $("btnReset").onclick = () => {
    // keep it simple: reload
    location.reload();
  };

  /***********************
   * Animation loop
   ***********************/
  function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // initial build
  buildPlate();
  resize();
  animate();
</script>
</body>
</html>



